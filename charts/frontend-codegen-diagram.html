<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Frontend Code Gen Approach</title>

    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dagre-d3@0.6.4/dist/dagre-d3.min.js"></script>

    <style>
      :root {
        --bg: #0b0d12;
        --panel: #0f1420;
        --muted: #9aa4b2;
        --text: #e5e7eb;
        --stroke: #2b3445;
        --accent: #60a5fa;
        --good: #34d399;
        --warn: #fbbf24;
        --purple: #a78bfa;
        --blue: #3b82f6;
        --orange: #fb923c;
      }
      html,
      body {
        height: 100vh;
        width: 100vw;
        margin: 0;
        padding: 0;
        overflow: hidden;
        max-width: none;
        box-sizing: border-box;
        background: var(--bg);
        color: var(--text);
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial;
      }
      * {
        box-sizing: border-box;
      }

      .wrap {
        width: 100vw;
        height: 100vh;
        max-width: none;
        display: grid;
        grid-template-columns: 1.35fr 0.65fr;
        gap: 16px;
        padding: 16px;
        box-sizing: border-box;
        margin: 0;
      }
      .wrap.right-collapsed {
        grid-template-columns: 1fr;
        padding: 0;
        gap: 0;
        width: 100vw;
        max-width: none;
      }
      .left {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0.02)
        );
        border: 1px solid var(--stroke);
        border-radius: 14px;
        overflow: hidden;
        position: relative;
        width: 100%;
        height: 100%;
        max-width: none;
        min-width: 0;
      }
      .wrap.right-collapsed .left {
        border-radius: 0;
        border-left: none;
        border-right: none;
        border-top: none;
        width: 100vw;
      }
      .toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 14px;
        border-bottom: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        gap: 12px;
        flex-wrap: wrap;
        position: relative;
        z-index: 10;
      }
      .title {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
        flex: 1;
      }
      .title h1 {
        font-size: 14px;
        margin: 0;
        letter-spacing: 0.2px;
      }
      .title p {
        font-size: 12px;
        margin: 0;
        color: var(--muted);
      }
      .tabs {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        position: relative;
        z-index: 11;
      }
      .tab {
        appearance: none;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 12px;
        cursor: pointer;
        position: relative;
        z-index: 12;
        pointer-events: auto;
        touch-action: manipulation;
        min-height: 36px;
      }
      .tab.active {
        border-color: rgba(96, 165, 250, 0.85);
        box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.15) inset;
      }
      .btns {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-left: auto;
        position: relative;
        z-index: 11;
      }
      button {
        appearance: none;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 12px;
        cursor: pointer;
        position: relative;
        z-index: 12;
        pointer-events: auto;
        touch-action: manipulation;
        min-height: 36px;
        min-width: 44px;
      }
      button:hover {
        border-color: rgba(96, 165, 250, 0.8);
      }
      button:active {
        transform: scale(0.98);
      }
      .svgWrap {
        position: absolute;
        inset: 58px 0 0 0;
        overflow: auto;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .right {
        background: var(--panel);
        border: 1px solid var(--stroke);
        border-radius: 14px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .rightHeader {
        padding: 12px 14px;
        border-bottom: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .rightHeaderContent {
        flex: 1;
      }
      .toggleBtn {
        appearance: none;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        padding: 6px 10px;
        border-radius: 8px;
        font-size: 12px;
        cursor: pointer;
        flex-shrink: 0;
      }
      .toggleBtn:hover {
        border-color: rgba(96, 165, 250, 0.8);
      }
      .right.collapsed {
        display: none;
      }
      .rightHeader h2 {
        margin: 0;
        font-size: 14px;
      }
      .rightHeader p {
        margin: 6px 0 0;
        font-size: 12px;
        color: var(--muted);
      }
      .card {
        padding: 14px;
        overflow: auto;
      }
      .card h3 {
        margin: 0 0 6px;
        font-size: 16px;
      }

      .pillRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin: 8px 0 12px;
      }
      .pill {
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        color: var(--muted);
        background: rgba(255, 255, 255, 0.02);
      }
      .pill.accent {
        border-color: rgba(96, 165, 250, 0.6);
        color: rgba(96, 165, 250, 0.95);
      }
      .pill.good {
        border-color: rgba(52, 211, 153, 0.6);
        color: rgba(52, 211, 153, 0.95);
      }
      .pill.warn {
        border-color: rgba(251, 191, 36, 0.6);
        color: rgba(251, 191, 36, 0.95);
      }
      .pill.purple {
        border-color: rgba(167, 139, 250, 0.6);
        color: rgba(167, 139, 250, 0.95);
      }
      .pill.blue {
        border-color: rgba(59, 130, 246, 0.6);
        color: rgba(59, 130, 246, 0.95);
      }
      .pill.orange {
        border-color: rgba(251, 146, 60, 0.6);
        color: rgba(251, 146, 60, 0.95);
      }

      .section {
        margin-top: 14px;
        padding-top: 12px;
        border-top: 1px dashed rgba(255, 255, 255, 0.12);
      }
      .section h4 {
        margin: 0 0 8px;
        font-size: 12px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      ul {
        margin: 0 0 0 18px;
        padding: 0;
        line-height: 1.5;
        font-size: 13px;
        color: var(--text);
      }
      li {
        margin: 6px 0;
      }

      svg {
        width: 100%;
        height: 100%;
        pointer-events: auto;
      }
      .node {
        cursor: pointer;
        pointer-events: auto;
      }
      .node rect {
        rx: 12px;
        ry: 12px;
        fill: rgba(255, 255, 255, 0.03);
        stroke: rgba(255, 255, 255, 0.16);
        stroke-width: 1.3px;
        pointer-events: auto;
      }
      .node.selected rect {
        stroke: rgba(96, 165, 250, 0.95);
        stroke-width: 2.4px;
      }
      .node text {
        fill: var(--text);
        font-weight: 650;
        font-size: 12px;
        pointer-events: none;
        user-select: none;
      }
      .node:hover rect {
        stroke: rgba(96, 165, 250, 0.6);
        stroke-width: 2px;
      }

      .edgePath path {
        stroke: rgba(255, 255, 255, 0.22);
        stroke-width: 1.4px;
        fill: none;
      }
      .edgeLabel text {
        fill: rgba(255, 255, 255, 0.6);
        font-size: 10px;
      }

      .dashed path {
        stroke-dasharray: 6 5;
        opacity: 0.95;
      }
      .strong path {
        stroke: rgba(96, 165, 250, 0.55);
        stroke-width: 2px;
      }
      .success path {
        stroke: rgba(52, 211, 153, 0.55);
        stroke-width: 2px;
      }

      @media (max-width: 768px) {
        .toolbar {
          padding: 10px 12px;
          gap: 10px;
        }
        .title {
          min-width: 0;
          width: 100%;
        }
        .title p {
          font-size: 11px;
        }
        .tabs {
          width: 100%;
          margin-top: 8px;
        }
        .tab {
          flex: 1;
          min-width: 0;
          font-size: 11px;
          padding: 10px 8px;
        }
        .btns {
          width: 100%;
          margin-left: 0;
          margin-top: 8px;
          justify-content: flex-start;
        }
        button {
          flex: 1;
          min-width: 0;
          font-size: 11px;
          padding: 10px 8px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="left">
        <div class="toolbar">
          <div class="title">
            <h1 id="viewTitle">Frontend Code Gen Approach</h1>
            <p id="viewSub">
              Generate frontend using your production components & patterns via
              Storybook docs, MCP context, and LLM code generation.
            </p>
          </div>
          <div class="tabs">
            <button class="tab active" id="tabStorybook">
              Storybook + MCP
            </button>
            <button class="tab" id="tabSpec">Spec-Driven YAML</button>
          </div>
          <div class="btns">
            <button id="btnCenter">Center view</button>
            <button id="btnReset">Reset selection</button>
            <button id="togglePanel" class="toggleBtn" title="Toggle panel">
              Panel
            </button>
          </div>
        </div>
        <div class="svgWrap">
          <svg id="svg"><g id="g"></g></svg>
        </div>
      </div>

      <div class="right" id="rightPanel">
        <div class="rightHeader">
          <div class="rightHeaderContent">
            <h2 id="panelTitle">Details</h2>
            <p id="panelSubtitle">Select a node in the diagram.</p>
          </div>
        </div>
        <div class="card" id="panel"></div>
      </div>
    </div>

    <script>
      // -----------------------------
      // View 1: STORYBOOK + MCP APPROACH
      // -----------------------------
      const storybookNodes = {
        storybook: {
          title: "Storybook for Design System Docs",
          pills: ["Documentation", "Component library", "Reference"],
          owns: [
            "Provides comprehensive design system documentation",
            "Shows all component variants, states, and props",
            "Documents usage patterns and best practices",
            "Serves as the source of truth for component APIs",
            "Includes interactive examples and code snippets",
          ],
          leverages: [
            "Storybook's component documentation features",
            "Story files that document each component",
            "Addons for accessibility, testing, and design tokens",
            "Auto-generated prop tables and controls",
          ],
          outputs: [
            "Component API documentation",
            "Usage examples and patterns",
            "Design system reference guide",
            "Component code examples",
          ],
        },

        mcp: {
          title: "MCP to Supply Frontend Context",
          pills: ["Context provider", "Codebase access", "Pattern discovery"],
          owns: [
            "Provides LLM with access to production codebase",
            "Supplies context about existing components and patterns",
            "Enables discovery of component usage across codebase",
            "Surfaces design system tokens and styling patterns",
            "Provides code examples from actual production code",
          ],
          leverages: [
            "Model Context Protocol (MCP) servers",
            "Codebase search and semantic understanding",
            "File system access to component libraries",
            "Pattern matching and code analysis",
          ],
          outputs: [
            "Contextual code examples",
            "Pattern recommendations",
            "Component usage insights",
            "Design system token references",
          ],
        },

        llm: {
          title: "LLM for Code Generation",
          pills: ["Code generation", "AI assistance", "Pattern matching"],
          owns: [
            "Generates frontend code using production components",
            "Matches user intent to existing component patterns",
            "Ensures generated code follows design system conventions",
            "Produces code that integrates with existing architecture",
            "Validates generated code against component APIs",
          ],
          leverages: [
            "Large Language Models (Claude, GPT, etc.)",
            "Context from Storybook documentation",
            "Context from MCP codebase access",
            "Design system knowledge and patterns",
            "Code generation prompts and templates",
          ],
          outputs: [
            "Generated frontend code",
            "Component compositions",
            "Pattern-based implementations",
            "Production-ready code snippets",
          ],
        },

        production: {
          title: "Production Components & Patterns",
          pills: ["Output", "Integration", "Consumption"],
          owns: [
            "Generated code that uses production components",
            "Code that follows established patterns and conventions",
            "Implementations that integrate with existing systems",
            "Frontend code ready for deployment",
          ],
          leverages: [
            "Existing component library from Storybook",
            "Patterns discovered via MCP",
            "Design system tokens and styling",
            "Production architecture and conventions",
          ],
          outputs: [
            "Production-ready frontend code",
            "Component-based implementations",
            "Pattern-consistent code",
            "Integrated frontend features",
          ],
        },
      };

      const storybookEdges = [
        {
          from: "storybook",
          to: "llm",
          label: "provides component docs",
          cls: "strong",
        },
        {
          from: "mcp",
          to: "llm",
          label: "supplies codebase context",
          cls: "strong",
        },
        {
          from: "llm",
          to: "production",
          label: "generates code",
          cls: "success",
        },
        {
          from: "storybook",
          to: "production",
          label: "reference patterns",
          cls: "dashed",
        },
        {
          from: "mcp",
          to: "production",
          label: "discovered patterns",
          cls: "dashed",
        },
      ];

      // -----------------------------
      // View 2: SPEC-DRIVEN YAML APPROACH
      // -----------------------------
      const specNodes = {
        yamlSpec: {
          title: "Component Spec (YAML)",
          pills: ["Contract", "API definition", "Deterministic"],
          owns: [
            "Defines component/block API: anatomy, props, variants, states, constraints",
            "Specifies token bindings (no raw values)",
            "Includes a11y acceptance criteria and requirements",
            "Documents component structure and behavior",
            "Serves as single source of truth for component contract",
          ],
          leverages: [
            "YAML/JSON format for structured component definitions",
            "Schema validation for consistency",
            "Version control for spec evolution",
            "Human-readable and machine-parseable format",
          ],
          outputs: [
            "Component/Block Spec files (YAML/JSON)",
            "Validated component contracts",
            "Build-ready specifications",
          ],
        },

        mcpSpec: {
          title: "MCP for Spec Context",
          pills: ["Context provider", "Spec access", "Pattern discovery"],
          owns: [
            "Provides LLM with access to component spec files",
            "Supplies context about existing component patterns from specs",
            "Enables discovery of component usage and relationships",
            "Surfaces token bindings and design system patterns from specs",
            "Provides spec-based code examples and patterns",
          ],
          leverages: [
            "Model Context Protocol (MCP) servers",
            "File system access to spec files",
            "Spec parsing and understanding",
            "Pattern matching across spec library",
          ],
          outputs: [
            "Spec-based context for code generation",
            "Component pattern recommendations",
            "Token binding references",
            "API usage examples from specs",
          ],
        },

        llmSpec: {
          title: "LLM Code Generation (Spec-Driven)",
          pills: ["Code generation", "Spec-based", "Deterministic"],
          owns: [
            "Generates frontend code from component specs",
            "Uses spec-defined APIs, props, and variants",
            "Ensures generated code matches spec contract exactly",
            "Produces code with proper token bindings (no raw values)",
            "Validates generated code against spec constraints",
          ],
          leverages: [
            "Large Language Models (Claude, GPT, etc.)",
            "Component spec files via MCP",
            "Spec schema and validation rules",
            "Design system token references from specs",
            "Spec-driven code generation prompts",
          ],
          outputs: [
            "Spec-compliant frontend code",
            "Component implementations matching spec API",
            "Token-bound styling (semantic tokens only)",
            "Production-ready code from contracts",
          ],
        },

        productionSpec: {
          title: "Production Components (Spec-Driven)",
          pills: ["Output", "Spec-compliant", "Contract-based"],
          owns: [
            "Generated code that strictly follows component specs",
            "Code that uses spec-defined APIs and variants",
            "Implementations with proper token bindings",
            "Frontend code ready for integration",
          ],
          leverages: [
            "Component specs as source of truth",
            "MCP-provided spec context",
            "Design system tokens referenced in specs",
            "Spec validation and compliance",
          ],
          outputs: [
            "Production-ready frontend code",
            "Spec-compliant component implementations",
            "Token-bound, maintainable code",
            "Contract-aligned frontend features",
          ],
        },
      };

      const specEdges = [
        {
          from: "yamlSpec",
          to: "mcpSpec",
          label: "provides spec files",
          cls: "strong",
        },
        {
          from: "mcpSpec",
          to: "llmSpec",
          label: "supplies spec context",
          cls: "strong",
        },
        {
          from: "yamlSpec",
          to: "llmSpec",
          label: "defines contract",
          cls: "strong",
        },
        {
          from: "llmSpec",
          to: "productionSpec",
          label: "generates spec-compliant code",
          cls: "success",
        },
        {
          from: "yamlSpec",
          to: "productionSpec",
          label: "contract reference",
          cls: "dashed",
        },
        {
          from: "mcpSpec",
          to: "productionSpec",
          label: "spec patterns",
          cls: "dashed",
        },
      ];

      // -----------------------------
      // Rendering helpers
      // -----------------------------
      const svg = d3.select("#svg");
      const inner = d3.select("#g");
      const render = new dagreD3.render();

      const panel = d3.select("#panel");
      const panelTitle = d3.select("#panelTitle");
      const panelSubtitle = d3.select("#panelSubtitle");

      const viewTitle = d3.select("#viewTitle");
      const viewSub = d3.select("#viewSub");

      let currentView = "storybook"; // storybook | spec
      let currentGraph = null;
      let currentNodes = null;

      const zoom = d3
        .zoom()
        .scaleExtent([0.5, 1.5])
        .on("zoom", (event) => inner.attr("transform", event.transform));
      svg.call(zoom);

      function setPanel(key) {
        const r = currentNodes[key];
        if (!r) return;
        panelTitle.text(r.title);
        panelSubtitle.text(
          "Details about this component in the frontend code generation approach.",
        );
        panel.html("");
        panel.append("h3").text(r.title);

        const pills = panel.append("div").attr("class", "pillRow");
        (r.pills || []).forEach((p, idx) => {
          let cls = "pill";
          if (idx === 0) {
            if (key === "storybook" || key === "yamlSpec") cls = "pill purple";
            else if (key === "mcp" || key === "mcpSpec") cls = "pill blue";
            else if (key === "llm" || key === "llmSpec") cls = "pill orange";
            else cls = "pill accent";
          } else if (idx === 1) {
            cls = "pill good";
          } else {
            cls = "pill warn";
          }
          pills.append("span").attr("class", cls).text(p);
        });

        const s1 = panel.append("div").attr("class", "section");
        s1.append("h4").text("Owns / Responsibilities");
        const ul1 = s1.append("ul");
        (r.owns || []).forEach((x) => ul1.append("li").text(x));

        const s2 = panel.append("div").attr("class", "section");
        s2.append("h4").text("Leverages / Tools");
        const ul2 = s2.append("ul");
        (r.leverages || []).forEach((x) => ul2.append("li").text(x));

        const s3 = panel.append("div").attr("class", "section");
        s3.append("h4").text("Outputs / Artifacts");
        const ul3 = s3.append("ul");
        (r.outputs || []).forEach((x) => ul3.append("li").text(x));
      }

      function clearSelection() {
        inner.selectAll("g.node").classed("selected", false);
      }

      function centerView() {
        if (!currentGraph) return;
        const graphWidth = currentGraph.graph().width;
        const graphHeight = currentGraph.graph().height;
        const svgWidth = svg.node().clientWidth;
        const svgHeight = svg.node().clientHeight;
        const scale = 0.9;
        const tx = Math.max(16, (svgWidth - graphWidth * scale) / 2);
        const ty = Math.max(30, (svgHeight - graphHeight * scale) / 2);
        svg
          .transition()
          .duration(350)
          .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
      }

      function buildGraph(nodes, edges) {
        const g = new dagreD3.graphlib.Graph({ multigraph: true })
          .setGraph({
            rankdir: "TB",
            nodesep: 60,
            ranksep: 100,
            marginx: 24,
            marginy: 22,
          })
          .setDefaultEdgeLabel(() => ({}));

        Object.entries(nodes).forEach(([key, r]) => {
          const base =
            "fill: rgba(255,255,255,0.03); stroke: rgba(255,255,255,0.16); stroke-width: 1.3px;";
          let style = base;
          if (key === "storybook" || key === "yamlSpec") {
            style =
              base +
              " stroke: rgba(167,139,250,0.7); stroke-width: 2px; fill: rgba(167,139,250,0.08);";
          } else if (key === "mcp" || key === "mcpSpec") {
            style =
              base +
              " stroke: rgba(59,130,246,0.7); stroke-width: 2px; fill: rgba(59,130,246,0.08);";
          } else if (key === "llm" || key === "llmSpec") {
            style =
              base +
              " stroke: rgba(251,146,60,0.7); stroke-width: 2px; fill: rgba(251,146,60,0.08);";
          } else if (key === "production" || key === "productionSpec") {
            style =
              base +
              " stroke: rgba(52,211,153,0.7); stroke-width: 2px; fill: rgba(52,211,153,0.08);";
          }
          g.setNode(key, {
            label: r.title,
            rx: 12,
            ry: 12,
            padding: 14,
            style,
          });
        });

        edges.forEach((e, i) => {
          g.setEdge(
            e.from,
            e.to,
            {
              label: e.label,
              class: e.cls || "",
              arrowhead: "vee",
              lineInterpolate: "basis",
            },
            `e${i}`,
          );
        });

        return g;
      }

      function renderView(view) {
        clearSelection();
        inner.selectAll("*").remove();

        if (view === "storybook") {
          currentView = "storybook";
          currentNodes = storybookNodes;
          viewTitle.text("Frontend Code Gen Approach");
          viewSub.text(
            "Generate frontend using your production components & patterns via Storybook docs, MCP context, and LLM code generation.",
          );

          currentGraph = buildGraph(storybookNodes, storybookEdges);
          render(inner, currentGraph);

          setPanel("storybook");
          inner
            .selectAll("g.node")
            .filter((d) => d === "storybook")
            .classed("selected", true);
        } else {
          currentView = "spec";
          currentNodes = specNodes;
          viewTitle.text("Spec-Driven Code Gen Approach");
          viewSub.text(
            "Generate frontend using component specs (YAML) as contracts, with MCP providing spec context to LLM for deterministic code generation.",
          );

          currentGraph = buildGraph(specNodes, specEdges);
          render(inner, currentGraph);

          setPanel("yamlSpec");
          inner
            .selectAll("g.node")
            .filter((d) => d === "yamlSpec")
            .classed("selected", true);
        }

        // Node click
        inner
          .selectAll("g.node")
          .style("cursor", "pointer")
          .on("click", function (event, key) {
            clearSelection();
            d3.select(this).classed("selected", true);
            setPanel(key);
          });

        // Improve edge label visibility
        inner.selectAll("g.edgeLabel").attr("opacity", 0.88);

        // Center
        centerView();
      }

      // Tabs
      const tabStorybook = d3.select("#tabStorybook");
      const tabSpec = d3.select("#tabSpec");

      function setActiveTab(which) {
        tabStorybook.classed("active", which === "storybook");
        tabSpec.classed("active", which === "spec");
      }

      tabStorybook.on("click", () => {
        setActiveTab("storybook");
        renderView("storybook");
      });
      tabSpec.on("click", () => {
        setActiveTab("spec");
        renderView("spec");
      });

      // Buttons
      d3.select("#btnCenter").on("click", centerView);
      d3.select("#btnReset").on("click", () => {
        clearSelection();
        panelTitle.text("Details");
        panelSubtitle.text("Select a node in the diagram.");
        panel.html("");
        // restore sensible defaults per view
        if (currentView === "storybook") {
          setPanel("storybook");
          inner
            .selectAll("g.node")
            .filter((d) => d === "storybook")
            .classed("selected", true);
        } else {
          setPanel("yamlSpec");
          inner
            .selectAll("g.node")
            .filter((d) => d === "yamlSpec")
            .classed("selected", true);
        }
        centerView();
      });

      // Initial render
      renderView("storybook");

      // Panel toggle
      const rightPanel = d3.select("#rightPanel");
      const wrap = d3.select(".wrap");
      const toggleBtn = d3.select("#togglePanel");

      function updateToggleButton() {
        const isCollapsed = rightPanel.classed("collapsed");
        toggleBtn.text(isCollapsed ? "Show Panel" : "Hide Panel");
        toggleBtn.attr("title", isCollapsed ? "Show panel" : "Hide panel");
      }

      toggleBtn.on("click", () => {
        const isCollapsed = rightPanel.classed("collapsed");
        rightPanel.classed("collapsed", !isCollapsed);
        wrap.classed("right-collapsed", !isCollapsed);
        updateToggleButton();
      });

      // Initialize button text
      updateToggleButton();
    </script>
  </body>
</html>
