<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Token Pipeline — Figma to NPM</title>

    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dagre-d3@0.6.4/dist/dagre-d3.min.js"></script>

    <style>
      :root {
        --bg: #0b0d12;
        --panel: #0f1420;
        --muted: #9aa4b2;
        --text: #e5e7eb;
        --stroke: #2b3445;
        --accent: #60a5fa;
        --good: #34d399;
        --warn: #fbbf24;
      }
      html,
      body {
        height: 100vh;
        width: 100vw;
        margin: 0;
        padding: 0;
        overflow: hidden;
        max-width: none;
        box-sizing: border-box;
        background: var(--bg);
        color: var(--text);
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial;
      }
      * {
        box-sizing: border-box;
      }

      .wrap {
        width: 100vw;
        height: 100vh;
        max-width: none;
        display: grid;
        grid-template-columns: 1.35fr 0.65fr;
        gap: 16px;
        padding: 16px;
        box-sizing: border-box;
        margin: 0;
      }
      .wrap.right-collapsed {
        grid-template-columns: 1fr;
        padding: 0;
        gap: 0;
        width: 100vw;
        max-width: none;
      }
      .left {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0.02)
        );
        border: 1px solid var(--stroke);
        border-radius: 14px;
        overflow: hidden;
        position: relative;
        width: 100%;
        height: 100%;
        max-width: none;
        min-width: 0;
      }
      .wrap.right-collapsed .left {
        border-radius: 0;
        border-left: none;
        border-right: none;
        border-top: none;
        width: 100vw;
      }
      .toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 14px;
        border-bottom: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        gap: 12px;
        flex-wrap: wrap;
      }
      .title {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 320px;
      }
      .title h1 {
        font-size: 14px;
        margin: 0;
        letter-spacing: 0.2px;
      }
      .title p {
        font-size: 12px;
        margin: 0;
        color: var(--muted);
      }
      .tabs {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .tab {
        appearance: none;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 12px;
        cursor: pointer;
      }
      .tab.active {
        border-color: rgba(96, 165, 250, 0.85);
        box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.15) inset;
      }
      .btns {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-left: auto;
      }
      button {
        appearance: none;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 12px;
        cursor: pointer;
      }
      button:hover {
        border-color: rgba(96, 165, 250, 0.8);
      }
      .svgWrap {
        position: absolute;
        inset: 58px 0 0 0;
        overflow: auto;
        width: 100%;
        height: 100%;
      }

      .right {
        background: var(--panel);
        border: 1px solid var(--stroke);
        border-radius: 14px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .rightHeader {
        padding: 12px 14px;
        border-bottom: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .rightHeaderContent {
        flex: 1;
      }
      .toggleBtn {
        appearance: none;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        padding: 6px 10px;
        border-radius: 8px;
        font-size: 12px;
        cursor: pointer;
        flex-shrink: 0;
      }
      .toggleBtn:hover {
        border-color: rgba(96, 165, 250, 0.8);
      }
      .right.collapsed {
        display: none;
      }
      .rightHeader h2 {
        margin: 0;
        font-size: 14px;
      }
      .rightHeader p {
        margin: 6px 0 0;
        font-size: 12px;
        color: var(--muted);
      }
      .card {
        padding: 14px;
        overflow: auto;
      }
      .card h3 {
        margin: 0 0 6px;
        font-size: 16px;
      }

      .pillRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin: 8px 0 12px;
      }
      .pill {
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        color: var(--muted);
        background: rgba(255, 255, 255, 0.02);
      }
      .pill.accent {
        border-color: rgba(96, 165, 250, 0.6);
        color: rgba(96, 165, 250, 0.95);
      }
      .pill.good {
        border-color: rgba(52, 211, 153, 0.6);
        color: rgba(52, 211, 153, 0.95);
      }
      .pill.warn {
        border-color: rgba(251, 191, 36, 0.6);
        color: rgba(251, 191, 36, 0.95);
      }

      .section {
        margin-top: 14px;
        padding-top: 12px;
        border-top: 1px dashed rgba(255, 255, 255, 0.12);
      }
      .section h4 {
        margin: 0 0 8px;
        font-size: 12px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      ul {
        margin: 0 0 0 18px;
        padding: 0;
        line-height: 1.5;
        font-size: 13px;
        color: var(--text);
      }
      li {
        margin: 6px 0;
      }

      svg {
        width: 100%;
        height: 100%;
      }
      .node rect {
        rx: 12px;
        ry: 12px;
        fill: rgba(255, 255, 255, 0.03);
        stroke: rgba(255, 255, 255, 0.16);
        stroke-width: 1.3px;
      }
      .node.selected rect {
        stroke: rgba(96, 165, 250, 0.95);
        stroke-width: 2.4px;
      }
      .node text {
        fill: var(--text);
        font-weight: 650;
        font-size: 12px;
      }

      .edgePath path {
        stroke: rgba(255, 255, 255, 0.22);
        stroke-width: 1.4px;
        fill: none;
      }
      .edgeLabel text {
        fill: rgba(255, 255, 255, 0.6);
        font-size: 10px;
      }

      .dashed path {
        stroke-dasharray: 6 5;
        opacity: 0.95;
      }
      .strong path {
        stroke: rgba(96, 165, 250, 0.55);
        stroke-width: 2px;
      }
      .success path {
        stroke: rgba(52, 211, 153, 0.55);
        stroke-width: 2px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="left">
        <div class="toolbar">
          <div class="title">
            <h1 id="viewTitle">Token Pipeline — Figma to NPM</h1>
            <p id="viewSub">
              Flow from token naming & taxonomy → Figma implementation → REST
              API → transformation → CSS → npm package distribution.
            </p>
          </div>
          <div class="tabs">
            <button class="tab active" id="tabSimple">Simple Flow</button>
            <button class="tab" id="tabComplex">Complex Flow</button>
          </div>
          <div class="btns">
            <button id="btnCenter">Center view</button>
            <button id="btnReset">Reset selection</button>
            <button id="togglePanel" class="toggleBtn" title="Toggle panel">Panel</button>
          </div>
        </div>
        <div class="svgWrap">
          <svg id="svg"><g id="g"></g></svg>
        </div>
      </div>

      <div class="right" id="rightPanel">
        <div class="rightHeader">
          <div class="rightHeaderContent">
            <h2 id="panelTitle">Details</h2>
            <p id="panelSubtitle">Select a node in the diagram.</p>
          </div>
        </div>
        <div class="card" id="panel"></div>
      </div>
    </div>

    <script>
      // -----------------------------
      // View 1: SIMPLE FLOW
      // -----------------------------
      const simpleNodes = {
        taxonomy: {
          title: "Token Naming & Taxonomy",
          pills: ["Design decisions", "Structure", "Naming conventions"],
          owns: [
            "Define token structure: Primitives → Semantics → Component hierarchy",
            "Establish naming conventions (e.g., spacing/16, color/primary/500)",
            "Define collections: Primitives (Core), Primitives (Color), Semantic, Component, Responsive",
            "Set mode/theme structure (light/dark, mobile/desktop/desktop-wide)",
          ],
          leverages: [
            "Design system documentation and governance",
            "Token taxonomy best practices and industry standards",
          ],
          outputs: [
            "Token naming schema and collection structure",
            "Documentation of token hierarchy and relationships",
          ],
        },

        figmaVariables: {
          title: "Figma Variables",
          pills: ["Figma UI", "Variable Collections", "Modes"],
          owns: [
            "Create and maintain Variable Collections in Figma",
            "Define variables with proper names following taxonomy (e.g., spacing/16)",
            "Set up modes for themes (light/dark) and responsive breakpoints",
            "Link semantic tokens to primitive tokens via aliases",
          ],
          leverages: [
            "Figma Variables UI (Shift+Cmd/Ctrl+K)",
            "Figma's variable binding and alias system",
          ],
          outputs: [
            "Variable Collections in Figma file",
            "Organized tokens ready for export via REST API",
          ],
        },

        figmaAPI: {
          title: "Figma REST API",
          pills: ["API sync", "Export", "Automation"],
          owns: [
            "Fetch variables from Figma file via REST API endpoint",
            "Authenticate using Figma personal access token (FIGMA_REST_API)",
            "Call GET /v1/files/{fileId}/variables/local",
            "Handle API responses and error cases",
          ],
          leverages: [
            "Figma REST API v1",
            "sync-figma-variables.js script (npm run tokens:sync)",
            "Environment variables for API token and file ID",
          ],
          outputs: [
            "Raw Figma variable data (JSON payload)",
            "Normalized variable and collection structures",
          ],
        },

        rawJSON: {
          title: "Raw JSON Files",
          pills: ["Intermediate storage", "Split by collection", "Metadata"],
          owns: [
            "Store full API response as raw.json",
            "Split tokens by collection and mode into separate files",
            "Generate metadata.json with sync info (file ID, collections, timestamps)",
            "File naming: <collection>-<id>.<mode>.json",
          ],
          leverages: [
            "File system operations (packages/design-tokens/tokens/)",
            "Collection and mode filtering logic",
          ],
          outputs: [
            "raw.json (full export)",
            "metadata.json (sync metadata)",
            "Collection-specific JSON files (primitives-core, primitives-color, semantic-color, etc.)",
          ],
        },

        transformation: {
          title: "Transformation & Processing",
          pills: ["Style Dictionary", "Custom transforms", "Unit conversion"],
          owns: [
            "Load and merge tokens from multiple JSON files",
            "Apply unit conversions (px → rem for spacing/typography)",
            "Transform typography (font-weight strings → numbers, line-height ratios)",
            "Process CSS output (hex shorthand, modern color syntax, zero unit removal)",
          ],
          leverages: [
            "Style Dictionary for token processing",
            "Custom transformers: unit-conversions.js, typography-transformers.js, css-processors.js",
            "build-tokens.js script (npm run tokens:build)",
          ],
          outputs: [
            "Processed token data ready for CSS generation",
            "Validated and normalized token values",
          ],
        },

        cssOutput: {
          title: "CSS Output",
          pills: ["CSS custom properties", "Dev + Minified", "Theme-aware"],
          owns: [
            "Generate CSS custom properties from processed tokens",
            "Create development files (dev/): individual, uncompressed CSS files",
            "Create production file (min/): consolidated, minified tokens.min.css",
            "Support theme-aware outputs (light/dark mode variants)",
          ],
          leverages: [
            "Style Dictionary CSS format",
            "CSS minification and consolidation",
            "Post-processing for modern CSS syntax",
          ],
          outputs: [
            "dev/tokens.primitives.css, tokens.semantic.css, etc.",
            "min/tokens.min.css (single consolidated file)",
            "Theme-specific variants (light/dark)",
          ],
        },

        npmPackage: {
          title: "NPM Package",
          pills: ["Distribution", "Versioned", "Consumable"],
          owns: [
            "Package CSS outputs and metadata into npm tarball",
            "Version the package (s2a-tokens-<version>.tgz)",
            "Include package.json with proper metadata",
            "Make package installable via npm install",
          ],
          leverages: [
            "package-tokens.js script (npm run package:tokens)",
            "NPM packaging tools",
            "Version management (version.js)",
          ],
          outputs: [
            "s2a-tokens-<version>.tgz tarball",
            "Installable npm package for Milo and other consumers",
            "Versioned releases with changelog",
          ],
        },
      };

      const simpleEdges = [
        {
          from: "taxonomy",
          to: "figmaVariables",
          label: "implements structure",
          cls: "strong",
        },
        {
          from: "figmaVariables",
          to: "figmaAPI",
          label: "export via API",
          cls: "strong",
        },
        {
          from: "figmaAPI",
          to: "rawJSON",
          label: "store as JSON",
          cls: "strong",
        },
        {
          from: "rawJSON",
          to: "transformation",
          label: "load & process",
          cls: "strong",
        },
        {
          from: "transformation",
          to: "cssOutput",
          label: "generate CSS",
          cls: "success",
        },
        {
          from: "cssOutput",
          to: "npmPackage",
          label: "package for distribution",
          cls: "success",
        },
      ];

      // -----------------------------
      // View 2: COMPLEX FLOW (with versioning, governance, etc.)
      // -----------------------------
      const complexNodes = {
        taxonomy: {
          title: "Token Naming & Taxonomy",
          pills: ["Design decisions", "Structure", "Naming conventions"],
          owns: [
            "Define token structure: Primitives → Semantics → Component hierarchy",
            "Establish naming conventions (e.g., spacing/16, color/primary/500)",
            "Define collections: Primitives (Core), Primitives (Color), Semantic, Component, Responsive",
            "Set mode/theme structure (light/dark, mobile/desktop/desktop-wide)",
          ],
          leverages: [
            "Design system documentation and governance",
            "Token taxonomy best practices and industry standards",
          ],
          outputs: [
            "Token naming schema and collection structure",
            "Documentation of token hierarchy and relationships",
          ],
        },

        governance: {
          title: "Governance & Validation",
          pills: ["Breaking changes", "Deprecations", "Validation"],
          owns: [
            "Define breaking change policies (removals, renames, structural changes)",
            "Track deprecations and migration paths",
            "Validate token completeness (all modes present, no missing references)",
            "Enforce naming conventions and structure rules",
            "Review and approve token changes before release",
          ],
          leverages: [
            "Automated validation checks in build pipeline",
            "Schema validation for token structure",
            "Breaking change detection (compare previous versions)",
          ],
          outputs: [
            "Validation reports and error messages",
            "Breaking change detection",
            "Deprecation notices and migration guides",
          ],
        },

        figmaVariables: {
          title: "Figma Variables",
          pills: ["Figma UI", "Variable Collections", "Modes"],
          owns: [
            "Create and maintain Variable Collections in Figma",
            "Define variables with proper names following taxonomy (e.g., spacing/16)",
            "Set up modes for themes (light/dark) and responsive breakpoints",
            "Link semantic tokens to primitive tokens via aliases",
          ],
          leverages: [
            "Figma Variables UI (Shift+Cmd/Ctrl+K)",
            "Figma's variable binding and alias system",
          ],
          outputs: [
            "Variable Collections in Figma file",
            "Organized tokens ready for export via REST API",
          ],
        },

        figmaAPI: {
          title: "Figma REST API",
          pills: ["API sync", "Export", "Automation"],
          owns: [
            "Fetch variables from Figma file via REST API endpoint",
            "Authenticate using Figma personal access token (FIGMA_REST_API)",
            "Call GET /v1/files/{fileId}/variables/local",
            "Handle API responses and error cases",
          ],
          leverages: [
            "Figma REST API v1",
            "sync-figma-variables.js script (npm run tokens:sync)",
            "Environment variables for API token and file ID",
          ],
          outputs: [
            "Raw Figma variable data (JSON payload)",
            "Normalized variable and collection structures",
          ],
        },

        rawJSON: {
          title: "Raw JSON Files",
          pills: ["Intermediate storage", "Split by collection", "Metadata"],
          owns: [
            "Store full API response as raw.json",
            "Split tokens by collection and mode into separate files",
            "Generate metadata.json with sync info (file ID, collections, timestamps)",
            "File naming: <collection>-<id>.<mode>.json",
          ],
          leverages: [
            "File system operations (packages/design-tokens/tokens/)",
            "Collection and mode filtering logic",
          ],
          outputs: [
            "raw.json (full export)",
            "metadata.json (sync metadata)",
            "Collection-specific JSON files (primitives-core, primitives-color, semantic-color, etc.)",
          ],
        },

        validation: {
          title: "Validation & Testing",
          pills: ["Schema validation", "Tests", "Quality gates"],
          owns: [
            "Validate token structure against schema",
            "Check for missing modes or incomplete token sets",
            "Verify unit conversions and transformations",
            "Run test suite (205 tests covering transformers and utilities)",
            "Ensure CSS output correctness",
          ],
          leverages: [
            "Automated test suite (unit tests for transformers)",
            "Schema validation tools",
            "CI/CD quality gates",
          ],
          outputs: [
            "Test results and coverage reports",
            "Validation errors and warnings",
            "Quality assurance for releases",
          ],
        },

        transformation: {
          title: "Transformation & Processing",
          pills: ["Style Dictionary", "Custom transforms", "Unit conversion"],
          owns: [
            "Load and merge tokens from multiple JSON files",
            "Apply unit conversions (px → rem for spacing/typography)",
            "Transform typography (font-weight strings → numbers, line-height ratios)",
            "Process CSS output (hex shorthand, modern color syntax, zero unit removal)",
          ],
          leverages: [
            "Style Dictionary for token processing",
            "Custom transformers: unit-conversions.js, typography-transformers.js, css-processors.js",
            "build-tokens.js script (npm run tokens:build)",
          ],
          outputs: [
            "Processed token data ready for CSS generation",
            "Validated and normalized token values",
          ],
        },

        cssOutput: {
          title: "CSS Output",
          pills: ["CSS custom properties", "Dev + Minified", "Theme-aware"],
          owns: [
            "Generate CSS custom properties from processed tokens",
            "Create development files (dev/): individual, uncompressed CSS files",
            "Create production file (min/): consolidated, minified tokens.min.css",
            "Support theme-aware outputs (light/dark mode variants)",
          ],
          leverages: [
            "Style Dictionary CSS format",
            "CSS minification and consolidation",
            "Post-processing for modern CSS syntax",
          ],
          outputs: [
            "dev/tokens.primitives.css, tokens.semantic.css, etc.",
            "min/tokens.min.css (single consolidated file)",
            "Theme-specific variants (light/dark)",
          ],
        },

        versioning: {
          title: "Versioning",
          pills: ["Semantic versioning", "Version bump", "Release management"],
          owns: [
            "Manage package version using semantic versioning (MAJOR.MINOR.PATCH)",
            "Bump version based on change type: patch (internal fixes), minor (additions), major (breaking)",
            "Update package.json version fields",
            "Track version history and release notes",
          ],
          leverages: [
            "version.js script (node version.js <patch|minor|major>)",
            "Semantic versioning standards (semver.org)",
            "Automated version bumping workflow",
          ],
          outputs: [
            "Updated package.json with new version",
            "Version metadata for release tracking",
          ],
        },

        changelog: {
          title: "Changelog Management",
          pills: ["Release notes", "Change tracking", "Documentation"],
          owns: [
            "Maintain CHANGELOG.md following Keep a Changelog format",
            "Document breaking changes, additions, improvements, and fixes",
            "Track changes per version with dates",
            "Include migration notes for breaking changes",
            "Copy changelog to npm package for distribution",
          ],
          leverages: [
            "Keep a Changelog format standard",
            "Manual curation of changes",
            "Automated changelog copy to dist/ during build",
          ],
          outputs: [
            "CHANGELOG.md in package root",
            "CHANGELOG.md included in npm package",
            "Versioned release documentation",
          ],
        },

        npmPackage: {
          title: "NPM Package",
          pills: ["Distribution", "Versioned", "Consumable"],
          owns: [
            "Package CSS outputs and metadata into npm tarball",
            "Version the package (s2a-tokens-<version>.tgz)",
            "Include package.json with proper metadata",
            "Include CHANGELOG.md and README.md in package",
            "Make package installable via npm install",
          ],
          leverages: [
            "package-tokens.js script (npm run package:tokens)",
            "NPM packaging tools",
            "Version management (version.js)",
          ],
          outputs: [
            "s2a-tokens-<version>.tgz tarball",
            "Installable npm package for Milo and other consumers",
            "Versioned releases with changelog",
          ],
        },

        release: {
          title: "Release Process",
          pills: ["CI/CD", "Distribution", "Communication"],
          owns: [
            "Coordinate release workflow: sync → build → validate → version → package",
            "Publish to npm registry (internal or public)",
            "Communicate releases to consumers (Milo, other apps)",
            "Track release history and adoption",
          ],
          leverages: [
            "CI/CD pipelines for automated releases",
            "NPM registry publishing",
            "Release communication channels",
          ],
          outputs: [
            "Published npm package",
            "Release announcements",
            "Distribution to consumers",
          ],
        },
      };

      const complexEdges = [
        {
          from: "taxonomy",
          to: "governance",
          label: "defines rules",
          cls: "strong",
        },
        {
          from: "governance",
          to: "figmaVariables",
          label: "validates structure",
          cls: "dashed",
        },
        {
          from: "taxonomy",
          to: "figmaVariables",
          label: "implements structure",
          cls: "strong",
        },
        {
          from: "figmaVariables",
          to: "figmaAPI",
          label: "export via API",
          cls: "strong",
        },
        {
          from: "figmaAPI",
          to: "rawJSON",
          label: "store as JSON",
          cls: "strong",
        },
        {
          from: "rawJSON",
          to: "validation",
          label: "validate structure",
          cls: "dashed",
        },
        {
          from: "rawJSON",
          to: "transformation",
          label: "load & process",
          cls: "strong",
        },
        {
          from: "validation",
          to: "transformation",
          label: "validated tokens",
          cls: "dashed",
        },
        {
          from: "transformation",
          to: "cssOutput",
          label: "generate CSS",
          cls: "success",
        },
        {
          from: "cssOutput",
          to: "versioning",
          label: "ready for version",
          cls: "dashed",
        },
        {
          from: "versioning",
          to: "changelog",
          label: "update changelog",
          cls: "dashed",
        },
        {
          from: "changelog",
          to: "npmPackage",
          label: "include in package",
          cls: "dashed",
        },
        {
          from: "cssOutput",
          to: "npmPackage",
          label: "package for distribution",
          cls: "success",
        },
        {
          from: "governance",
          to: "versioning",
          label: "determines version type",
          cls: "dashed",
        },
        {
          from: "npmPackage",
          to: "release",
          label: "publish & distribute",
          cls: "success",
        },
      ];

      // -----------------------------
      // Rendering helpers
      // -----------------------------
      const svg = d3.select("#svg");
      const inner = d3.select("#g");
      const render = new dagreD3.render();

      const panel = d3.select("#panel");
      const panelTitle = d3.select("#panelTitle");
      const panelSubtitle = d3.select("#panelSubtitle");

      const viewTitle = d3.select("#viewTitle");
      const viewSub = d3.select("#viewSub");

      let currentView = "simple"; // simple | complex
      let currentGraph = null;
      let currentNodes = null;

      const zoom = d3
        .zoom()
        .scaleExtent([0.5, 1.35])
        .on("zoom", (event) => inner.attr("transform", event.transform));
      svg.call(zoom);

      function setPanel(key) {
        const r = currentNodes[key];
        if (!r) return;
        panelTitle.text(r.title);
        panelSubtitle.text(
          "Details about this stage in the token pipeline process.",
        );
        panel.html("");
        panel.append("h3").text(r.title);

        const pills = panel.append("div").attr("class", "pillRow");
        (r.pills || []).forEach((p, idx) => {
          const cls =
            idx === 0 ? "pill accent" : idx === 1 ? "pill good" : "pill warn";
          pills.append("span").attr("class", cls).text(p);
        });

        const s1 = panel.append("div").attr("class", "section");
        s1.append("h4").text("Owns / Responsibilities");
        const ul1 = s1.append("ul");
        (r.owns || []).forEach((x) => ul1.append("li").text(x));

        const s2 = panel.append("div").attr("class", "section");
        s2.append("h4").text("Leverages / Tools");
        const ul2 = s2.append("ul");
        (r.leverages || []).forEach((x) => ul2.append("li").text(x));

        const s3 = panel.append("div").attr("class", "section");
        s3.append("h4").text("Outputs / Artifacts");
        const ul3 = s3.append("ul");
        (r.outputs || []).forEach((x) => ul3.append("li").text(x));
      }

      function clearSelection() {
        inner.selectAll("g.node").classed("selected", false);
      }

      function centerView() {
        if (!currentGraph) return;
        const graphWidth = currentGraph.graph().width;
        const svgWidth = svg.node().clientWidth;
        const scale = currentView === "simple" ? 0.85 : 0.7;
        const tx = Math.max(16, (svgWidth - graphWidth * scale) / 2);
        const ty = 30;
        svg
          .transition()
          .duration(350)
          .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
      }

      function buildGraph(nodes, edges) {
        const g = new dagreD3.graphlib.Graph({ multigraph: true })
          .setGraph({
            rankdir: "LR",
            nodesep: 50,
            ranksep: 80,
            marginx: 24,
            marginy: 22,
          })
          .setDefaultEdgeLabel(() => ({}));

        Object.entries(nodes).forEach(([key, r]) => {
          const base =
            "fill: rgba(255,255,255,0.03); stroke: rgba(255,255,255,0.16); stroke-width: 1.3px;";
          const style =
            key === "taxonomy" || key === "npmPackage"
              ? base + " stroke: rgba(96,165,250,0.9); stroke-width: 2px;"
              : base;
          g.setNode(key, { label: r.title, rx: 12, ry: 12, padding: 14, style });
        });

        edges.forEach((e, i) => {
          g.setEdge(
            e.from,
            e.to,
            {
              label: e.label,
              class: e.cls || "",
              arrowhead: "vee",
              lineInterpolate: "basis",
            },
            `e${i}`,
          );
        });

        return g;
      }

      function renderView(view) {
        clearSelection();
        inner.selectAll("*").remove();

        if (view === "simple") {
          currentView = "simple";
          currentNodes = simpleNodes;
          viewTitle.text("Token Pipeline — Figma to NPM");
          viewSub.text(
            "Simple flow: token naming & taxonomy → Figma implementation → REST API → transformation → CSS → npm package distribution.",
          );

          currentGraph = buildGraph(simpleNodes, simpleEdges);
          render(inner, currentGraph);

          setPanel("taxonomy");
          inner
            .selectAll("g.node")
            .filter((d) => d === "taxonomy")
            .classed("selected", true);
        } else {
          currentView = "complex";
          currentNodes = complexNodes;
          viewTitle.text("Token Pipeline — Complex Flow (with Governance)");
          viewSub.text(
            "Complete flow including governance, validation, versioning, changelog management, and release processes.",
          );

          currentGraph = buildGraph(complexNodes, complexEdges);
          render(inner, currentGraph);

          setPanel("taxonomy");
          inner
            .selectAll("g.node")
            .filter((d) => d === "taxonomy")
            .classed("selected", true);
        }

        // Node click
        inner
          .selectAll("g.node")
          .style("cursor", "pointer")
          .on("click", function (event, key) {
            clearSelection();
            d3.select(this).classed("selected", true);
            setPanel(key);
          });

        // Improve edge label visibility
        inner.selectAll("g.edgeLabel").attr("opacity", 0.88);

        // Center
        centerView();
      }

      // Tabs
      const tabSimple = d3.select("#tabSimple");
      const tabComplex = d3.select("#tabComplex");

      function setActiveTab(which) {
        tabSimple.classed("active", which === "simple");
        tabComplex.classed("active", which === "complex");
      }

      tabSimple.on("click", () => {
        setActiveTab("simple");
        renderView("simple");
      });
      tabComplex.on("click", () => {
        setActiveTab("complex");
        renderView("complex");
      });

      // Buttons
      d3.select("#btnCenter").on("click", centerView);
      d3.select("#btnReset").on("click", () => {
        clearSelection();
        panelTitle.text("Details");
        panelSubtitle.text("Select a node in the diagram.");
        panel.html("");
        // restore sensible defaults per view
        if (currentView === "simple") {
          setPanel("taxonomy");
          inner
            .selectAll("g.node")
            .filter((d) => d === "taxonomy")
            .classed("selected", true);
        } else {
          setPanel("taxonomy");
          inner
            .selectAll("g.node")
            .filter((d) => d === "taxonomy")
            .classed("selected", true);
        }
        centerView();
      });

      // Initial render
      renderView("simple");

      // Panel toggle
      const rightPanel = d3.select("#rightPanel");
      const wrap = d3.select(".wrap");
      const toggleBtn = d3.select("#togglePanel");
      
      function updateToggleButton() {
        const isCollapsed = rightPanel.classed("collapsed");
        toggleBtn.text(isCollapsed ? "Show Panel" : "Hide Panel");
        toggleBtn.attr("title", isCollapsed ? "Show panel" : "Hide panel");
      }
      
      toggleBtn.on("click", () => {
        const isCollapsed = rightPanel.classed("collapsed");
        rightPanel.classed("collapsed", !isCollapsed);
        wrap.classed("right-collapsed", !isCollapsed);
        updateToggleButton();
      });
      
      // Initialize button text
      updateToggleButton();
    </script>
  </body>
</html>
